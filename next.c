// Software License Agreement (ISC License)
//
// Copyright (c) 2019, Matthew Voss
//
// Permission to use, copy, modify, and/or distribute this software for
// any purpose with or without fee is hereby granted, provided that the
// above copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

#include <stdlib.h>
#include <stdio.h>
#include "next.h"

// In the descriptions below, transition from prior position state (state zero) to new position state (state 1) is
// abbreviated to : s0 -> s1.  The position map maps from all valid s0 states to s1 states by
// combining with the ascii character (c) encountered.  IOW, the int-int map is:  s0 + c -> s1.

// create an int-int map from (s0 + c) -- to --> (new pos)
int POS_MAP[0x480];         // highest position is 0x400.  Higest ascii char is 0x7F.  Array length is +1.
char* POS2NAME[0x401];      // map position constants to name codes

// ASCII flags
int NON_TOKEN = 1;           // '\b\f\n\t\r ,:',
int DELIM = 2;               // '\b\f\n\t\r ,:{}[]',
int DECIMAL_END = 4;         // '0123456789',
int DECIMAL_ASCII = 8;       // '-0123456789+.eE',
int NO_LEN_TOKENS = 16;      // 'tfn[]{}()',

//       0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
//    -----------------------------------------------------------------------------------
// 0  |  NUL  SOH  STX  ETX  EOT  ENQ  ACK  BEL  BS   TAB  LF   VT   FF   CR   SO   SI  |  // 0
// 1  |  DLE  DC1  DC2  DC3  DC4  NAK  SYN  ETB  CAN  EM   SUB  ESC  FS   GS   RS   US  |  // 1
// 2  |  SPC  !    "    #    $    %    &    '    (    )    *    +    ,    -    .    /   |  // 2
// 3  |  0    1    2    3    4    5    6    7    8    9    :    ;    <    =    >    ?   |  // 3
// 4  |  @    A    B    C    D    E    F    G    H    I    J    K    L    M    N    O   |  // 4
// 5  |  P    Q    R    S    T    U    V    W    X    Y    Z    [    \    ]    ^    _   |  // 5
// 6  |  `    a    b    c    d    e    f    g    h    i    j    k    l    m    n    o   |  // 6
// 7  |  p    q    r    s    t    u    v    w    x    y    z    {    |    }    ~        |  // 7
//    -----------------------------------------------------------------------------------

// CMAP was lovingly crafted by util.js (set to ASCII flags, above)
char CMAP[] = {
//0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F
  0,    0,    0,    0,    0,    0,    0,    0,    0x03, 0x03, 0x03, 0,    0x03, 0x03, 0,    0,    // 0
  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    // 1
  0x03, 0,    0,    0,    0,    0,    0,    0,    0x10, 0x10, 0,    0x08, 0x03, 0x08, 0x08, 0,    // 2
  0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x03, 0,    0,    0,    0,    0,    // 3
  0,    0,    0,    0,    0,    0x08, 0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    // 4
  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0x12, 0,    0x12, 0,    0,    // 5
  0,    0,    0,    0,    0,    0x08, 0x10, 0,    0,    0,    0,    0,    0,    0,    0x10, 0,    // 6
  0,    0,    0,    0,    0x10, 0,    0,    0,    0,    0,    0,    0x12, 0,    0x12, 0,    0,    // 7
  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    // 8
  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    // 9
  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    // A
  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    // B
  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    // C
  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    // D
  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    // E
  0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    // F
};

// "one-time" initialization.  Note that although it is possible to enter the init
// code simultaneously with different threads, it would be very rare and all operations
// within are atomic and redudant - and so safe for multiple threads.
static void mod_init () {
  // pos_pairs is generated by utils.js
  int pos_pairs[] = {
    219,128,221,384,228,384,230,384,238,384,243,384,244,384,251,512,
    347,128,356,384,358,384,366,384,371,384,372,384,379,512,428,256,
    477,384,627,768,637,384,755,768,826,896,987,128,996,1024,998,1024,
    1006,1024,1011,1024,1012,1024,1019,512,1068,640,1149,384,
  };
  int len = sizeof(pos_pairs)/sizeof(int);
  for (int i=0; i<len; i+=2) {
    POS_MAP[pos_pairs[i]] = pos_pairs[i+1];
  }

  // POS2NAME
  POS2NAME[POS_A_BF] = "A_BF";
  POS2NAME[POS_A_BV] = "A_BV";
  POS2NAME[POS_A_AV] = "A_AV";
  POS2NAME[POS_O_BF] = "O_BF";
  POS2NAME[POS_O_BK] = "O_BK";
  POS2NAME[POS_O_AK] = "O_AK";
  POS2NAME[POS_O_BV] = "O_BV";
  POS2NAME[POS_O_AV] = "O_AV";
}

pstate* new_ps (char* src, int off, int lim, int max_depth) {
  pstate* ps = malloc(sizeof(pstate));
  ps->tok = 0;
  ps->src = src;
  ps->src_len = 0;
  ps->soff = off;
  ps->koff = off;
  ps->klim = off;
  ps->voff = off;
  ps->vlim = off;
  ps->pos = POS_A_BF;
  ps->line = 1;
  ps->lineoff = 1;
  ps->lim = lim;
  ps->stack = malloc(sizeof(int) * max_depth);
  return ps;
}

// switch ps->src to ps->next_src if conditions are right (ps->src is null or is complete without errors)
static int next_src (pstate* ps) {
  if (ps->ecode || (ps->src && ps->vlim < ps->lim)) {
    return 0;
  }
  if (ps->next_src_len == 0) {
    ps->next_src = NULL;
    return 0;
  }
  ps->soff += ps->src && ps->src_len || 0;
  ps->src = ps->next_src;
  ps->next_src = NULL;
  ps->koff = ps->klim = ps->voff = ps->vlim = ps->tok = ps->ecode = 0;
  ps->lim = ps->next_src_len;
  return 1;
}

// skip as many bytes of src that match bsrc, up to lim.
// return
//     i    the new index after all bytes are matched (past matched bytes)
//    -i    (negative) the index of the first unmatched byte (past matched bytes)
static int skip_bytes (char* src, int off, int lim, char* bsrc) {
  int i = off;
  while (i < lim && src[i] == bsrc[i - off]) { i++; }
  return bsrc[i-off] == 0 ? i : -i;
}

// pstate summaries of the form:
// k3@4:s5@8        - key length 3 at offset 4 : value length 5 at offset 8.
// d2@6             - decimal 2 at offset 6
// [@4              - array start at offset 4
// ]@12             - array end at offset 12
int tokstr (char* buf, int lim, pstate* ps, int detail) {
  int off = 0;
  // key
  if (ps->klim > ps->koff) {
    off += snprintf(buf, lim, "k%d@%d:", ps->klim - ps->koff, ps->koff);
  }
  // value
  off += snprintf(buf+off, lim-off, "%c", ps->tok ? (char) ps->tok : '!');
  switch ((char) ps->tok) {
    case 't': case 'f': case 'n': case '[': case ']': case '{': case '}': case '(': case ')':
      break; // no length
    default:
      off += snprintf(buf+off, lim-off, "%d", ps->vlim - ps->voff);
  }
  off += snprintf(buf+off, lim-off, "@%d", ps->voff);
  return off;
}

static int end_src (pstate* ps, next_opt* opt) {
  switch (ps->ecode) {
    case 0:
      if (ps->pos == POS_O_AK || ps->pos == POS_O_BV) {
        ps->ecode = ECODE_KEY_NO_VAL;
      } else {
        if (ps->next_src && next_src(ps)) { return next(ps, opt); }
      }
      break;
    case ECODE_BAD_VALUE: case ECODE_UNEXPECTED:
      if (opt != NULL && opt->err != NULL) {
        opt->err(ps);      // may clear error code and reset ps->tok
      }
      return ps->tok;        // tok and ecode are sticky unless set by err().
    // default: any other ecode is just sticky (prevents progress)
  }
  ps->tok = 0;
  return ps->tok;
}

static int handle_neg (pstate* ps, next_opt* opt) {
  ps->vlim = -ps->vlim;
  if (ps->vlim >= ps->lim) {
    ps->ecode =
      ps->tok == TOK_DEC &&
      (CMAP[(int) ps->src[ps->vlim - 1]] & DECIMAL_END)
        ? ECODE_TRUNC_DEC
        : ECODE_TRUNCATED;
  } else {
    ps->ecode = ECODE_BAD_VALUE;
    ps->vlim++;
  }
  return end_src(ps, opt);
}

static int handle_unexp (pstate* ps, next_opt* opt) {
  if (ps->vlim < 0) { ps->vlim = -ps->vlim; }
  ps->ecode = ECODE_UNEXPECTED;
  return end_src(ps, opt);
}

// starting after the first quote, return the index of the character just past the closing quote of
// the string, or negative index if no closing quote is found (handles escapes)
static int skip_str (char* src, int off, int lim) {
  // this while loop allows parallel loading on multi-processor machines.
  char* s2 = src + off;
  do {
    if (s2[0] == 34) { break; }
    if (s2[1] == 34) { s2 += 1; break; }
    if (s2[2] == 34) { s2 += 2; break; }
    if (s2[3] == 34) { s2 += 3; break; }
    s2 += 4;
  } while (s2[0] != 34);

  int i = s2 - src;
  while (i < lim) {
    if (src[i] == 34) {
      if (src[i - 1] == 92) {
        // count number of escapes going backwards (n = escape count +1)
        int n = 2;
        while (src[i - n] == 92 && i - n >= off) { n++; }       // \ BACKSLASH escape
        if (n % 2 == 1) {
          return i + 1;  // skip quote
        }
      } else {
        return i + 1;    // skip quote
      }
    }
    i++;
  }
//  if (i > lim) { i = lim; }
  return -i;
}

static int skip_dec (char* src, int off, int lim) {
  char* s2 = src + off;
  do {
    if ((CMAP[(int)s2[0]] & DECIMAL_ASCII) == 0) { break; }
    if ((CMAP[(int)s2[1]] & DECIMAL_ASCII) == 0) { s2 += 1; break; }
    if ((CMAP[(int)s2[2]] & DECIMAL_ASCII) == 0) { s2 += 2; break; }
    if ((CMAP[(int)s2[3]] & DECIMAL_ASCII) == 0) { s2 += 3; break; }
    s2 += 4;
  } while ((CMAP[(int)s2[0]] & DECIMAL_ASCII) != 0);
  int i = s2 - src;
  return (i < lim && (CMAP[(int) src[i]] & DELIM)) ? i : -lim;
}

void print_ps (pstate* ps) {
    printf("tok:%c pos:%s koff:%d klim:%d voff:%d vlim:%d ec:%c\n", ps->tok, posname(ps->pos), ps->koff, ps->klim, ps->voff, ps->vlim, ps->ecode);
}

int INITIALIZED = 0;
int next (pstate* ps, next_opt* opt) {
  if (!INITIALIZED) {
    mod_init();
    INITIALIZED = 1;
  }
  if (ps->ecode != 0) {                                  // ecode is sticky (requires intentional fix)
    ps->tok = 0;
    return 0;
  }
  ps->koff = ps->klim = ps->voff = ps->vlim;
  int pos1 = ps->pos;
  while (ps->vlim < ps->lim) {
    ps->voff = ps->vlim;
    ps->tok = ps->src[ps->vlim++];
    switch (ps->tok) {
      case 10:                                          // new-line
        ps->lineoff = ps->soff + ps->vlim;
        ps->line++;
        continue;

      case 13:                                          // carriage return
        ps->lineoff = ps->soff + ps->vlim;
        continue;

      case 8: case 9: case 12: case 32:                 // other white-space
        continue;

      case 44:                                          // ,    COMMA
      case 58:                                          // :    COLON
        pos1 = POS_MAP[ps->pos | ps->tok];
        if (pos1 == 0) { ps->voff = ps->vlim - 1; return handle_unexp(ps, opt); }
        ps->pos = pos1;
        continue;

      case 34:                                          // "    QUOTE
        ps->tok = 115;                                  // s for string
        ps->vlim = skip_str(ps->src, ps->vlim, ps->lim);
        pos1 = POS_MAP[ps->pos | ps->tok];
        if (pos1 == 0) return handle_unexp(ps, opt);
        if (pos1 == POS_O_AK) {
          // key
          ps->koff = ps->voff;
          if (ps->vlim > 0) { ps->pos = pos1; ps->klim = ps->voff = ps->vlim; continue; } else { ps->klim = ps->voff = -ps->vlim; return handle_neg(ps, opt); }
        } else {
          // value
          if (ps->vlim > 0) { ps->pos = pos1; ps->vcount++; return ps->tok; } else return handle_neg(ps, opt);
        }

      case 102:                                         // f    false
        ps->vlim = skip_bytes(ps->src, ps->vlim, ps->lim, "alse");
        pos1 = POS_MAP[ps->pos | ps->tok];
        if (pos1 == 0) return handle_unexp(ps, opt);
        if (ps->vlim > 0) { ps->pos = pos1; ps->vcount++; return ps->tok; } else return handle_neg(ps, opt);
      case 110:                                         // n    null
        ps->vlim = skip_bytes(ps->src, ps->vlim, ps->lim, "ull");
        pos1 = POS_MAP[ps->pos | ps->tok];
        if (pos1 == 0) return handle_unexp(ps, opt);
        if (ps->vlim > 0) { ps->pos = pos1; ps->vcount++; return ps->tok; } else return handle_neg(ps, opt);
      case 116:                                         // t    true
        ps->vlim = skip_bytes(ps->src, ps->vlim, ps->lim, "rue");
        pos1 = POS_MAP[ps->pos | ps->tok];
        if (pos1 == 0) return handle_unexp(ps, opt);
        if (ps->vlim > 0) { ps->pos = pos1; ps->vcount++; return ps->tok; } else return handle_neg(ps, opt);

      case 48:case 49:case 50:case 51:case 52:          // 0-4    digits
      case 53:case 54:case 55:case 56:case 57:          // 5-9    digits
      case 45:                                          // '-'    ('+' is not legal here)
        ps->tok = 100;                                   // d for decimal
        ps->vlim = skip_dec(ps->src, ps->vlim, ps->lim);
        pos1 = POS_MAP[ps->pos | ps->tok];
        if (pos1 == 0) return handle_unexp(ps, opt);
        if (ps->vlim > 0) { ps->pos = pos1; ps->vcount++; return ps->tok; } else return handle_neg(ps, opt);

      case 91:                                          // [    ARRAY START
      case 123:                                         // {    OBJECT START
        pos1 = POS_MAP[ps->pos | ps->tok];
        if (pos1 == 0) return handle_unexp(ps, opt);
        ps->pos = pos1;
        ps->stack[ps->stack_len++] = ps->tok;
        return ps->tok;

      case 93:                                          // ]    ARRAY END
        if (POS_MAP[ps->pos | ps->tok] == 0) return handle_unexp(ps, opt);
        ps->stack_len--;
        ps->pos = ps->stack[ps->stack_len - 1] == 123 ? POS_O_AV : POS_A_AV;
        ps->vcount++; return ps->tok;

      case 125:                                         // }    OBJECT END
        if (POS_MAP[ps->pos | ps->tok] == 0) return handle_unexp(ps, opt);
        ps->stack_len--;
        ps->pos = ps->stack[ps->stack_len - 1] == 123 ? POS_O_AV : POS_A_AV;
        ps->vcount++; return ps->tok;

      default:
        --ps->vlim;
        ps->ecode = ECODE_BAD_VALUE;
        return end_src(ps, opt);
    }
  }

  // reached src limit without error or truncation
  if (CMAP[ps->tok] & NON_TOKEN) {
    ps->voff = ps->vlim;
  }
  return end_src(ps, opt);
}

char* posname (int pos) {
  return POS2NAME[pos] ? POS2NAME[pos] : "NONE";
}

